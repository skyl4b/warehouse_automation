from __future__ import annotations

from typing import TYPE_CHECKING, ClassVar, cast

import rclpy
import yaml
from rcl_interfaces import msg as rcl_msgs
from rclpy.node import Node
from std_msgs import msg as std_msgs
from wa_interfaces import srv as wa_srvs

from wa_warehouse_control.sct.automaton import (
    Automaton,
    AutomatonTransitions,
)
from wa_warehouse_control.sct.plant_node import SPECIAL_DELIMITER

if TYPE_CHECKING:
    from rclpy.client import Client
    from rclpy.publisher import Publisher


class SupervisorNode(Node):
    """A supervisor (in the SCT sense) ROS node.

    Supervisory Control Theory (SCT) defines supervisors as "functions" that
    take the strings (sequences of events) generated by the plant as inputs
    and provide possible future events that the plant may undergo.
    Effectively, the supervisor disables future events that don't follow
    the specifications used in its design.

    Note that the events it disables must be "controllable"
    in the Ramadge-Wonham sense, e.g. may be disabled.

    The enabled events are published in a "enabled_events" topic with
    the events being published as a string that joins the event names
    with the '|' character.
    """

    name: ClassVar[str] = "supervisor"
    """Default node name."""

    namespace: ClassVar[str] = "/wa"
    """Default node namespace."""

    enabled_events_publisher: Publisher
    """Publisher for enabled events."""

    automaton: Automaton
    """Automaton that generates the supervisor's language."""

    register: Client
    """A client to register the supervisor to the plant."""

    id_: int | None
    """Supervisor id provided by the plant."""

    def __init__(self, state: str, transitions: AutomatonTransitions) -> None:
        super().__init__(  # pyright: ignore[reportArgumentType]
            node_name=self.name,
            namespace=self.namespace,
        )

        # Parameters
        self.declare_parameter("state", state)
        self.declare_parameter("transitions", yaml.safe_dump(transitions))
        self.create_subscription(  # Monitor set parameter
            rcl_msgs.ParameterEvent,
            "/parameter_events",
            self.parameter_event_callback,
            10,
        )

        # Variables
        self.automaton = Automaton(self.state, self.transitions)
        self.id_ = None

        # Subscribers
        self.create_subscription(
            std_msgs.String,
            "plant/sct/event",
            self.event_callback,
            10,
        )
        # Clients
        self.register = self.create_client(
            wa_srvs.RegisterSupervisor,
            """plant/sct/register_supervisor""",
        )

        # Publishers
        self.enabled_events_publisher = self.create_publisher(
            std_msgs.String,
            "plant/sct/enabled_events",
            10,
        )

        # Wait for plant to be available
        while not self.register.wait_for_service(5.0):
            self.get_logger().info("Waiting for plant to be available")
        self.register.call_async(
            wa_srvs.RegisterSupervisor.Request(
                enabled_events=SPECIAL_DELIMITER.join(self.automaton.current_events()),
            ),
        ).add_done_callback(self.register_callback)

    @property
    def state(self) -> str:
        """The last externally set state of the supervisor automaton."""
        return self.get_parameter("state").value  # pyright: ignore[reportReturnType]

    @property
    def transitions(self) -> AutomatonTransitions:
        """The transitions that define the supervisor automaton."""
        return yaml.safe_load(
            self.get_parameter("transitions").value,  # pyright: ignore[reportArgumentType]
        )

    def parameter_event_callback(
        self,
        message: rcl_msgs.ParameterEvent,
    ) -> None:
        """Monitor this node's parameters to update the automaton."""
        if message.node == self.get_fully_qualified_name():
            for parameter in message.changed_parameters:
                if parameter.name == "state":
                    # Set current state
                    self.automaton.state = self.state
                elif parameter.name == "transitions":
                    # Set the possible transitions (rebuild automaton)
                    self.automaton = Automaton(self.state, self.transitions)

    def register_callback(self, future: rclpy.Future) -> None:
        """Set supervisor id according to the plant's response."""
        response = cast(wa_srvs.RegisterSupervisor.Response, future.result())
        self.id_ = response.supervisor_id
        self.get_logger().info(f"Supervisor id '{self.id_}' set")

    def event_callback(self, message: std_msgs.String) -> None:
        """Respond to a plant event, with the currently enabled events."""
        self.automaton.transition(message.data)
        if self.id_ is None:
            self.get_logger().error(
                "Event observer without a supervisor id being set.",
            )
            return
        self.publish_enabled_events()

    def publish_enabled_events(self) -> None:
        """Publish the current enabled events."""
        self.enabled_events_publisher.publish(
            std_msgs.String(
                data=SPECIAL_DELIMITER.join(
                    [str(self.id_), *self.automaton.current_events()],
                ),
            ),
        )
        self.get_logger().info(
            f"Enabled events {self.automaton.current_events()}",
        )


def main() -> None:
    """Run the supervisor node."""
    rclpy.init()
    node = SupervisorNode(
        state="q0",
        transitions={
            "q0": {
                "a": "q1",
            },
            "q1": {
                "b": "q0",
            },
        },
    )

    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.try_shutdown()


if __name__ == "__main__":
    main()
